package ch.cyberduck.core.s3;

/*
 * Copyright (c) 2002-2014 David Kocher. All rights reserved.
 * http://cyberduck.io/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * Bug fixes, suggestions and comments should be sent to:
 * feedback@cyberduck.io
 */

import ch.cyberduck.core.Host;

import org.apache.log4j.Logger;
import org.jets3t.service.security.ProviderCredentials;
import org.jets3t.service.utils.RestUtils;
import org.jets3t.service.utils.ServiceUtils;

import java.util.Collections;

/**
 * @version $Id$
 */
public class S3SignedUrlProvider {
    private static final Logger log = Logger.getLogger(S3SignedUrlProvider.class);

    private Host endpoint;

    public S3SignedUrlProvider(final Host endpoint) {
        this.endpoint = endpoint;
    }

    /**
     * Generates a signed URL string that will grant access to an S3 resource (bucket or object)
     * to whoever uses the URL up until the time specified.
     *
     * @param specialParamName          the name of a request parameter to add to the URL generated by this method. 'Special'
     *                                  parameters may include parameters that specify the kind of S3 resource that the URL
     *                                  will refer to, such as 'acl', 'torrent', 'logging', or 'location'.
     * @param isDnsBucketNamingDisabled if true, the signed URL will not use the DNS-name format for buckets eg.
     *                                  <tt>jets3t.s3.amazonaws.com</tt>. Unless you have a specific reason to disable
     *                                  DNS bucket naming, leave this value false.
     * @param method                    the HTTP method to sign, such as GET or PUT (note that S3 does not support POST requests).
     * @param bucket                    the name of the bucket to include in the URL, must be a valid bucket name.
     * @param key                       the name of the object to include in the URL, if null only the bucket name is used.
     * @param secondsSinceEpoch         the time after which URL's signature will no longer be valid. This time cannot be null.
     *                                  <b>Note:</b> This time is specified in seconds since the epoch, not milliseconds.
     * @param isVirtualHost             if this parameter is true, the bucket name is treated as a virtual host name. To use
     *                                  this option, the bucket name must be a valid DNS name that is an alias to an S3 bucket.
     * @param isHttps                   if true, the signed URL will use the HTTPS protocol. If false, the signed URL will
     *                                  use the HTTP protocol.
     * @return a URL signed in such a way as to grant access to an S3 resource to whoever uses it.
     */
    public String create(final ProviderCredentials credentials,
                         final String method, final String bucket, final String key,
                         final long secondsSinceEpoch,
                         final boolean isVirtualHost, final boolean isHttps) {
        String s3Endpoint = endpoint.getHostname();
        String uriPath;

        String hostname = (isVirtualHost
                ? bucket
                : ServiceUtils.generateS3HostnameForBucket(
                bucket, false, s3Endpoint));

        // If we are using an alternative hostname, include the hostname/bucketname in the resource path.
        String virtualBucketPath = "";
        if(!s3Endpoint.equals(hostname)) {
            int subdomainOffset = hostname.lastIndexOf("." + s3Endpoint);
            if(subdomainOffset > 0) {
                // Hostname represents an S3 sub-domain, so the bucket's name is the CNAME portion
                virtualBucketPath = hostname.substring(0, subdomainOffset) + "/";
            }
            else {
                // Hostname represents a virtual host, so the bucket's name is identical to hostname
                virtualBucketPath = hostname + "/";
            }
            uriPath = (key != null ? RestUtils.encodeUrlPath(key, "/") : "");
        }
        else {
            uriPath = bucket + (key != null ? "/" + RestUtils.encodeUrlPath(key, "/") : "");
        }
        uriPath += "?";
        uriPath += "AWSAccessKeyId=" + credentials.getAccessKey();
        uriPath += "&Expires=" + secondsSinceEpoch;

        String serviceEndpointVirtualPath = "";

        String canonicalString = RestUtils.makeServiceCanonicalString(method,
                serviceEndpointVirtualPath + "/" + virtualBucketPath + uriPath,
                Collections.<String, Object>emptyMap(), String.valueOf(secondsSinceEpoch),
                "x-amz-", Collections.<String>emptyList());
        if(log.isDebugEnabled()) {
            log.debug("Signing canonical string:\n" + canonicalString);
        }

        String signedCanonical = ServiceUtils.signWithHmacSha1(credentials.getSecretKey(),
                canonicalString);
        String encodedCanonical = RestUtils.encodeUrlString(signedCanonical);
        uriPath += "&Signature=" + encodedCanonical;

        return endpoint.getProtocol().getScheme() + "://" + hostname
                + (endpoint.getPort() != endpoint.getProtocol().getScheme().getPort() ? ":" + endpoint.getPort() : "")
                + serviceEndpointVirtualPath
                + "/" + uriPath;
    }
}
