package ch.cyberduck.core.sds;

/*
 * Copyright (c) 2002-2017 iterate GmbH. All rights reserved.
 * https://cyberduck.io/
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */

import ch.cyberduck.core.Host;
import ch.cyberduck.core.HostPasswordStore;
import ch.cyberduck.core.LocaleFactory;
import ch.cyberduck.core.LoginOptions;
import ch.cyberduck.core.PasswordCallback;
import ch.cyberduck.core.PasswordStoreFactory;
import ch.cyberduck.core.exception.BackgroundException;
import ch.cyberduck.core.exception.LoginCanceledException;
import ch.cyberduck.core.features.Background;
import ch.cyberduck.core.preferences.PreferencesFactory;
import ch.cyberduck.core.sds.io.swagger.client.ApiException;
import ch.cyberduck.core.sds.io.swagger.client.api.NodesApi;
import ch.cyberduck.core.sds.io.swagger.client.api.UserApi;
import ch.cyberduck.core.sds.io.swagger.client.model.FileFileKeys;
import ch.cyberduck.core.sds.io.swagger.client.model.MissingKeysResponse;
import ch.cyberduck.core.sds.io.swagger.client.model.UserAccount;
import ch.cyberduck.core.sds.io.swagger.client.model.UserFileKeySetBatchRequest;
import ch.cyberduck.core.sds.io.swagger.client.model.UserFileKeySetRequest;
import ch.cyberduck.core.sds.io.swagger.client.model.UserIdFileIdItem;
import ch.cyberduck.core.sds.io.swagger.client.model.UserKeyPairContainer;
import ch.cyberduck.core.sds.io.swagger.client.model.UserUserPublicKey;
import ch.cyberduck.core.sds.triplecrypt.CryptoExceptionMappingService;
import ch.cyberduck.core.sds.triplecrypt.TripleCryptConverter;
import ch.cyberduck.core.threading.ScheduledThreadPool;
import ch.cyberduck.core.vault.VaultCredentials;
import ch.cyberduck.core.worker.DefaultExceptionMappingService;

import org.apache.log4j.Logger;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.stream.Collectors;

import eu.ssp_europe.sds.crypto.Crypto;
import eu.ssp_europe.sds.crypto.CryptoException;
import eu.ssp_europe.sds.crypto.model.EncryptedFileKey;
import eu.ssp_europe.sds.crypto.model.PlainFileKey;
import eu.ssp_europe.sds.crypto.model.UserKeyPair;
import eu.ssp_europe.sds.crypto.model.UserPrivateKey;

public class SDSBackgroundFeature implements Background {
    private static final Logger log = Logger.getLogger(SDSBackgroundFeature.class);

    private final SDSSession session;
    private final long period;

    private final ScheduledThreadPool scheduler = new ScheduledThreadPool();
    private final CountDownLatch exit = new CountDownLatch(1);

    private final HostPasswordStore keychain = PasswordStoreFactory.get();

    public SDSBackgroundFeature(final SDSSession session) {
        this(session, PreferencesFactory.get().getLong("sds.encryption.missingkeys.scheduler.period"));
    }

    public SDSBackgroundFeature(final SDSSession session, final long period) {
        this.session = session;
        this.period = period;
    }

    protected List<UserFileKeySetRequest> processMissingKeys(final PasswordCallback callback) {
        final List<UserFileKeySetRequest> processed = new ArrayList<>();
        try {
            // Requests a list of missing FileKeys that may be generated by the current user.
            // Clients should regularly request missing FileKeys to provide access to files for other users. The returned list is ordered by priority (Rescue Keys are returned first)
            final UserAccount account = new UserApi(session.getClient()).getUserInfo(session.getToken(), null, false);
            if(!account.getIsEncryptionEnabled()) {
                return processed;
            }
            final UserPrivateKey privateKey = new UserPrivateKey();
            final UserKeyPairContainer keyPairContainer = new UserApi(session.getClient()).getUserKeyPair(session.getToken());
            privateKey.setPrivateKey(keyPairContainer.getPrivateKeyContainer().getPrivateKey());
            privateKey.setVersion(keyPairContainer.getPrivateKeyContainer().getVersion());
            final Host bookmark = session.getHost();
            final VaultCredentials passphrase = new VaultCredentials(
                    keychain.getPassword(bookmark.getHostname(),
                            String.format("Triple-Crypt Encryption Password (%s)", bookmark.getCredentials().getUsername()))) {
            };
            final UserKeyPair keypair = new UserKeyPair();
            keypair.setUserPrivateKey(privateKey);
            this.unlock(callback, bookmark, passphrase, keypair);
            final MissingKeysResponse missingKeys = new NodesApi(session.getClient()).missingFileKeys(session.getToken(),
                    null, null, null, null, null);
            final Map<Long, UserUserPublicKey> publicKeys =
                    missingKeys.getUsers().stream().collect(Collectors.toMap(UserUserPublicKey::getId, Function.identity()));
            final Map<Long, FileFileKeys> files =
                    missingKeys.getFiles().stream().collect(Collectors.toMap(FileFileKeys::getId, Function.identity()));
            final UserFileKeySetBatchRequest request = new UserFileKeySetBatchRequest();
            for(UserIdFileIdItem item : missingKeys.getItems()) {
                final UserUserPublicKey publicKey = publicKeys.get(item.getUserId());
                final FileFileKeys fileKeys = files.get(item.getFileId());
                final UserFileKeySetRequest keySetRequest = new UserFileKeySetRequest()
                        .fileId(item.getFileId())
                        .userId(item.getUserId());
                processed.add(keySetRequest);
                final PlainFileKey plainFileKey = Crypto.decryptFileKey(
                        TripleCryptConverter.toCryptoEncryptedFileKey(fileKeys.getFileKeyContainer()), privateKey, passphrase.getPassword());
                final EncryptedFileKey encryptFileKey = Crypto.encryptFileKey(
                        plainFileKey, TripleCryptConverter.toCryptoUserPublicKey(publicKey.getPublicKeyContainer())
                );
                keySetRequest.setFileKey(TripleCryptConverter.toSwaggerFileKey(encryptFileKey));
                request.addItemsItem(keySetRequest);
            }
            if(!request.getItems().isEmpty()) {
                new NodesApi(session.getClient()).setUserFileKeys(session.getToken(), request);
            }
        }
        catch(ApiException e) {
            final BackgroundException failure = new SDSExceptionMappingService().map(e);
            log.warn(String.format("Failure refreshing missing file keys. %s", failure.getDetail()));
        }
        catch(CryptoException e) {
            final BackgroundException failure = new CryptoExceptionMappingService().map(e);
            log.warn(String.format("Failure while processing missing file keys. %s", failure.getDetail()));
        }
        catch(LoginCanceledException e) {
            log.warn("Password prompt cancelled");
        }
        return processed;
    }

    private void unlock(final PasswordCallback callback, final Host bookmark, final VaultCredentials passphrase, final UserKeyPair keypair) throws CryptoException, LoginCanceledException {
        if(null == passphrase.getPassword()) {
            callback.prompt(passphrase,
                    LocaleFactory.localizedString("Private key password protected", "Credentials"),
                    LocaleFactory.localizedString("Enter your encryption password", "Credentials"),
                    new LoginOptions()
                            .user(false)
                            .anonymous(false)
                            .icon(bookmark.getProtocol().disk())
            );
            if(passphrase.getPassword() == null) {
                throw new LoginCanceledException();
            }
        }
        if(!Crypto.checkUserKeyPair(keypair, passphrase.getPassword())) {
            passphrase.setPassword(null);
            this.unlock(callback, bookmark, passphrase, keypair);
        }
        else {
            if(passphrase.isSaved()) {
                if(log.isInfoEnabled()) {
                    log.info(String.format("Save encryption password for %s", bookmark));
                }
                keychain.addPassword(bookmark.getHostname(),
                        String.format("Triple-Crypt Encryption Password (%s)", bookmark.getCredentials().getUsername()),
                        passphrase.getPassword());
            }
        }
    }

    @Override
    public void run(final PasswordCallback callback) throws BackgroundException {
        scheduler.repeat(() -> {
            this.processMissingKeys(callback);
        }, period, TimeUnit.MILLISECONDS);
        try {
            exit.await();
        }
        catch(InterruptedException e) {
            log.error(String.format("Error waiting for exit signal %s", e.getMessage()));
            throw new DefaultExceptionMappingService().map(e);
        }
    }

    @Override
    public void shutdown() {
        exit.countDown();
        scheduler.shutdown();
    }
}
